// SMAANeighborhoodBlending.usf
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "SMAACommon.ush"

Texture2D ColorTexture;
SamplerState ColorSampler;
Texture2D BlendTexture; // The weights from previous pass
SamplerState BlendSampler;

float2 InvTextureSize;
uint DebugMode;

void MainPS(
    noperspective float4 UVAndScreenPos : TEXCOORD0,
    float4 SvPosition : SV_POSITION,
    out float4 OutColor : SV_Target0
)
{
    float2 UV = UVAndScreenPos.xy;
    
    // Fetch weights
    // R = Weight for Current/Right blending (from Top Edge)
    // G = Weight for Current/Left blending ?
    // Actually, based on BlendingWeight shader:
    // If Top Edge: R = Weight for Pixel to Left? G = Weight for Pixel to Right?
    // Let's stick to standard SMAA logic for reconstruction.
    
    // Standard SMAA Neighborhood Blending:
    // 1. Fetch weights at current pixel.
    // 2. Fetch weights at neighbor pixels to see if *they* want to blend with us.
    
    // Our weights (calculated in previous pass):
    // R, G came from Top Edge.
    // B, A came from Left Edge.
    
    float4 weights = BlendTexture.SampleLevel(BlendSampler, UV, 0);
    
    // If DebugMode is enabled, pass through the BlendTexture (which contains the debug visualization)
    if (DebugMode > 0)
    {
        OutColor = weights;
        return;
    }

    float2 pixSize = InvTextureSize;
    float4 color = float4(0, 0, 0, 0);
    
    // Blending logic:
    // If we have a Top Edge (weights.r/g > 0), we blend vertically? No, Top Edge means vertical blend across the edge.
    // Wait, Top Edge separates Current(x,y) and Top(x, y-1).
    // So we blend C and T based on weights.
    
    // Simplified Neighborhood Blending (Bilinear):
    // We determine a blending offset.
    
    float2 offset = float2(0, 0);
    float totalWeight = 0.0;
    
    // Check Top Edge weights (Stored in R, G)
    // If weights.g > 0, it means we blend with the top pixel?
    // Let's assume standard SMAA behavior:
    // The blend texture tells us how much to mix with the *neighbor*.
    
    // Let's implement a high-quality 4-tap blend based on weights
    
    float3 C = ColorTexture.SampleLevel(ColorSampler, UV, 0).rgb;
    
    // If no weights, return original
    if (dot(weights, float4(1,1,1,1)) < 0.001)
    {
        OutColor = float4(C, 1);
        return;
    }
    
    // Calculate blend vector
    // R: Blend with Right?
    // G: Blend with Top?
    // B: Blend with Left?
    // A: Blend with Bottom?
    // Note: The previous pass outputs R/G for Horizontal Edge (Top boundary) and B/A for Vertical Edge (Left boundary).
    
    // This is getting complex to reverse engineer without the exact mapping.
    // Let's use a "Weighted Bilinear" approach which is very close to SMAA 1x.
    
    // We look at the 4 edges surrounding the pixel.
    // Current pixel (x,y) has Top Edge (weights.rg) and Left Edge (weights.ba).
    // We also need the Bottom Edge (from pixel below) and Right Edge (from pixel to right).
    
    float4 rightWeights = BlendTexture.SampleLevel(BlendSampler, UV + float2(pixSize.x, 0), 0);
    float4 bottomWeights = BlendTexture.SampleLevel(BlendSampler, UV + float2(0, pixSize.y), 0);
    
    // Horizontal blending (across vertical edges)
    // Left Edge weight: weights.b (or a?)
    // Right Edge weight: rightWeights.b
    
    float weightLeft = weights.b;   // Weight from Left Edge
    float weightTop = weights.r;    // Weight from Top Edge
    float weightRight = rightWeights.b; // Weight from Right Edge (of neighbor)
    float weightBottom = bottomWeights.r; // Weight from Bottom Edge (of neighbor)
    
    // Determine the dominant direction
    float2 blendOffset = float2(0, 0);
    
    if (max(weightLeft, weightRight) > max(weightTop, weightBottom))
    {
        // Horizontal Blend
        if (weightLeft > weightRight)
        {
            blendOffset = float2(-weightLeft * 0.5, 0); // Shift left
        }
        else
        {
            blendOffset = float2(weightRight * 0.5, 0); // Shift right
        }
    }
    else
    {
        // Vertical Blend
        if (weightTop > weightBottom)
        {
            blendOffset = float2(0, -weightTop * 0.5); // Shift up
        }
        else
        {
            blendOffset = float2(0, weightBottom * 0.5); // Shift down
        }
    }
    
    // Use bilinear sampler with the calculated offset
    // The offset shifts the UV so the bilinear filter automatically blends the two pixels
    float3 BlendedC = ColorTexture.SampleLevel(ColorSampler, UV + blendOffset * pixSize, 0).rgb;
    
    OutColor = float4(BlendedC, 1);
}
