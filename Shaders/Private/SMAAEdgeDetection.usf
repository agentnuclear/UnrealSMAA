// SMAAEdgeDetection.usf
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "SMAACommon.ush"

Texture2D ColorTexture;
SamplerState ColorSampler;
Texture2D DepthTexture; // For future use
SamplerState DepthSampler;

float2 InvTextureSize; // (1/w, 1/h)
float Threshold;
uint EdgeDetectionMode; // 0=Luma, 1=Color, 2=Depth
uint DebugMode;

// Calculate Luma
float GetLuma(float3 Color)
{
    return dot(Color, float3(0.299, 0.587, 0.114));
}

void MainPS(
    noperspective float4 UVAndScreenPos : TEXCOORD0,
    float4 SvPosition : SV_POSITION,
    out float4 OutColor : SV_Target0
)
{
    float2 UV = UVAndScreenPos.xy;
    
    // Standard SMAA Edge Detection typically checks Left and Top boundaries of the pixel
    // We compare Current (C) with Left (L) and Top (T)
    
    float3 C = ColorTexture.SampleLevel(ColorSampler, UV, 0).rgb;
    float3 L = ColorTexture.SampleLevel(ColorSampler, UV + float2(-InvTextureSize.x, 0), 0).rgb;
    float3 T = ColorTexture.SampleLevel(ColorSampler, UV + float2(0, -InvTextureSize.y), 0).rgb;
    
    float2 Delta;
    
    if (EdgeDetectionMode == 0) // Luma
    {
        float LumaC = GetLuma(C);
        float LumaL = GetLuma(L);
        float LumaT = GetLuma(T);
        
        Delta.x = abs(LumaC - LumaL); // Left edge
        Delta.y = abs(LumaC - LumaT); // Top edge
    }
    else // Color (Max difference)
    {
        float3 DeltaC = abs(C - L);
        float3 DeltaT = abs(C - T);
        
        Delta.x = max(max(DeltaC.r, DeltaC.g), DeltaC.b);
        Delta.y = max(max(DeltaT.r, DeltaT.g), DeltaT.b);
    }
    
    // Thresholding
    float2 Edges = step(Threshold, Delta);
    
    // Discard if no edges (optimization)
    if (dot(Edges, float2(1, 1)) == 0)
    {
        discard;
    }
    
    // Output: R=Left Edge, G=Top Edge
    OutColor = float4(Edges, 0, 0);
    
    if (DebugMode == 1)
    {
        OutColor = float4(Edges.x, Edges.y, 0, 1);
    }
}
